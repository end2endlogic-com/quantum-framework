version: 1
classes:
  - id: Order
  - id: Customer
  - id: Organization
  - id: Shipment
  - id: Address
  - id: Region
  # Chain inference test classes
  - id: ChainClassA
  - id: ChainClassB
  - id: ChainClassC
  - id: ChainClassD

properties:
  - id: placedBy
    domain: Order
    range: Customer
    functional: true
    transitive: false
  - id: memberOf
    domain: Customer
    range: Organization
  - id: orderHasShipment
    domain: Order
    range: Shipment
  - id: shipsTo
    domain: Shipment
    range: Address
  - id: locatedIn
    domain: Address
    range: Region
  - id: ancestorOf
    domain: Organization
    range: Organization
    transitive: true
  # implied predicates
  - id: placedInOrg
    domain: Order
    range: Organization
  - id: orderShipsTo
    domain: Order
    range: Address
  - id: orderShipsToRegion
    domain: Order
    range: Region
  # Chain inference test properties
  - id: refersToB
    domain: ChainClassA
    range: ChainClassB
    functional: true
  - id: refersToC
    domain: ChainClassB
    range: ChainClassC
    functional: true
  - id: refersToD
    domain: ChainClassB
    range: ChainClassD
    functional: true
  # Implied properties from chains
  - id: impliedRefersToC
    domain: ChainClassA
    range: ChainClassC
    inferred: true
  - id: impliedRefersToD
    domain: ChainClassA
    range: ChainClassD
    inferred: true

chains:
  - chain: [placedBy, memberOf]
    implies: placedInOrg
  - chain: [orderHasShipment, shipsTo]
    implies: orderShipsTo
  - chain: [orderShipsTo, locatedIn]
    implies: orderShipsToRegion
  # Note: Removed [placedInOrg, ancestorOf] => placedInOrg chain because
  # ancestorOf is transitive and chains cannot contain transitive properties (non-regular).
  # Transitive properties get their closure computed separately.
  # Chain inference test: A->B->C implies A->C
  - chain: [refersToB, refersToC]
    implies: impliedRefersToC
  # Chain inference test: A->B->D implies A->D
  - chain: [refersToB, refersToD]
    implies: impliedRefersToD
